;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUBLIC _fft                         ;                                       ;
                                    ;                                       ;
.486                                ;                                       ;
.model flat                         ;                                       ;
.data                               ;                                       ;
.code                               ;                                       ;
                                    ; no stackframe. Just:                  ;
                                    ;                                       ;
_fft PROC                           ; [-------] ESP                         ;
                                    ; [RETADDR]     [ESP+0]                 ;
                                    ; [POINTER] f = [ESP+4]                 ;
                                    ; [INTEGER] n = [ESP+8]                 ;
                                    ; [INTEGER] s = [ESP+12]                ;
                                    ;                                       ;
                                    ;                                       ;
    MOV     EBX, [ESP+8]            ; ebx contains length of function       ;
    MOV     EDX, EBX                ; so does edx                           ;
                                    ;                                       ;
    FINIT                           ; initialize Floating Point Unit        ;
    FSTENV  [ESP-28]                ;                                       ;
    FILD    DWORD PTR [ESP+12]      ; load forward/backwards indicator      ;
    FLD     ST(0)                   ; push another copy of s on the stack   ;
    FABS                            ; |s|,s on stack                        ;
    FDIVP   ST(1), ST(0)            ; set ST(0) to s/|s| = sgn(s)           ;
    FIST    DWORD PTR [ESP+12]      ; store the result in s, do not pop     ;
    FLD1                            ; load 1 onto stack                     ;
    FLDPI                           ; load pi onto stack                    ;
    FSCALE                          ; scaling pi by 2                       ;
    FSTP    ST(1)                   ; now, ST(0) = 2*pi                     ;
    FMULP   ST(1), ST(0)            ; ST(0) = 2*pi*sgn(s)                   ;
    FIDIV   DWORD PTR [ESP+8]       ; ST(0) = 2*pi*sng(s)/n                 ;
    FSINCOS                         ; cos(ST(0)),sin(ST(0)) on stack.       ;
                                    ;                                       ;
                                    ; We now have w on stack:               ;
                                    ;  ST(0) = Re(w)                        ;
                                    ;  ST(1) = Im(w)                        ;
                                    ;                                       ;
    MOV     ESI, [ESP+4]            ; esi = f                               ;
    CMP     DWORD PTR [ESP+12], 1   ; check,                                ;
    JE      START                   ; do not scale if s != 1                ;
    FILD    DWORD PTR [ESP+8]       ; push n onto FPU stack                 ;
    MOV     ECX, EBX                ; n values to be scaled                 ;
    SHL     ECX, 1                  ; each value consists of 2 doubles      ;
SCALE:                              ;                                       ;
    FLD     QWORD PTR [ESI+8*ECX-8] ; push double on the stack              ;
    FDIV    ST(0), ST(1)            ; scale by n                            ;
    FSTP    QWORD PTR [ESI+8*ECX-8] ; store scaled double                   ;
    LOOP    SCALE                   ; loop until ecx=0                      ;
    FCOMP                           ; pop n off the FPU stack again.        ;
 ;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;
 ; In terms of the C version of the algorithm, we will use the ebx register ;
 ; as N, the ecx register as j, the eax register as k and the edx register  ;
 ; as M.                                                                    ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    ;                                       ;
START:                              ;                                       ;
    CMP     EBX, 1                  ; Only contiune to transform as         ;
    JNG     ENDFUN                  ; long as N > 1.                        ;
    SHR     EDX, 1                  ; Set M := N >> 1;                      ;
    XOR     ECX, ECX                ; start new loop with j=0               ;
INNER1:                             ;                                       ;
    FLDZ                            ; push 0 onto FPU stack                 ;
    FLD1                            ; push 1 onto FPU stack                 ;
                                    ;                                       ;
                                    ; w and the initial z on the FPU stack: ;
                                    ; ST(0) = Re(z)                         ;
                                    ; ST(1) = Im(z)                         ;
                                    ; ST(2) = Re(w)                         ;
                                    ; ST(3) = Im(w)                         ;
                                    ;                                       ;
    XOR     EAX, EAX                ; start new loop with k=0               ;
INNER2:                             ;                                       ;
    ADD     EAX, ECX                ; for indexing, we need k+j             ;
    MOV     EDI, EAX                ; and                                   ;
    ADD     EDI, EDX                ; k+j+M                                 ;
                                    ;                                       ;
    SHL     EAX, 4                  ; we are indexing 16-byte COMPLEX       ;
    SHL     EDI, 4                  ; values, scale indices                 ;
                                    ;                                       ;
    FLD     QWORD PTR [ESI+EDI+8]   ; ST(2)  = f[j+k+M].imag                ;
    FLD     QWORD PTR [ESI+EAX+8]   ; ST(1)  = f[j+k].imag                  ;
    FLD     ST(1)                   ; ST(0)  = f[j+k+M].imag                ;
    FADD    ST(0), ST(1)            ; ST(0)  = f[j+k].imag + f[j+k+M].imag  ;
    FSTP    QWORD PTR [ESI+EAX+8]   ; f[j+k] = f[j+k].imag + f[j+k+M].imag  ;
    FSUBRP  ST(1), ST(0)            ; ST(0)  = f[j+k].imag - f[j+k+M].imag  ;
                                    ;                                       ;
                                    ; Now, the same procedure is performed  ;
                                    ; for the real parts of the two complex ;
                                    ; variables:                            ;
                                    ;                                       ;
    FLD     QWORD PTR [ESI+EDI]     ;                                       ;
    FLD     QWORD PTR [ESI+EAX]     ;                                       ;
    FLD     ST(1)                   ;                                       ;
    FADD    ST(0), ST(1)            ;                                       ;
    FSTP    QWORD PTR [ESI+EAX]     ;                                       ;
    FSUBRP  ST(1), ST(0)            ;                                       ;
                                    ;  the FPU stack now looks like this:   ;
                                    ;                                       ;
                                    ;  ST0 = Real(a), a=f[j+k]-f[j+k+M]     ;
                                    ;  ST1 = Imag(a)                        ;
                                    ;  ST2 = Real(z)                        ;
                                    ;  ST3 = Imag(z)                        ;
                                    ;  ST4 = Real(w)                        ;
                                    ;  ST5 = Imag(w)                        ;
                                    ;                                       ;
                                    ; we want to calculate a*z and store it ;
                                    ; in f[j+k+M].                          ;
                                    ;                                       ;
    FLD     ST(0)                   ; push Re(a)                            ;
    FMUL    ST(0), ST(3)            ; ST(0) <- Re(z)*Re(a)                  ;
    FLD     ST(2)                   ; push Im(a)                            ;
    FMUL    ST(0), ST(5)            ; ST(0) <- Im(a)*Im(z)                  ;
    FSUBP   ST(1), ST(0)            ; TOS   <- ST(1)-ST(0)                  ;
    FSTP    QWORD PTR [ESI+EDI]     ; pop to f[j+k+M].real                  ;
                                    ; stack back to [a,z,w]                 ;
    FMUL    ST(0), ST(3)            ; ST(0) <- Re(a)*Im(z)                  ;
    FXCH    ST(1)                   ; ST(0) <-> ST(1)                       ;
    FMUL    ST(0), ST(2)            ; ST(1) <- Im(a)*Re(z)                  ;
    FADDP   ST(1), ST(0)            ; TOS   <- ST(0)+ST(1)                  ;
    FSTP    QWORD PTR [ESI+EDI+8]   ; pop to f[j+k+M].imag                  ;
                                    ;                                       ;
                                    ; We now have only z and w on the FPU   ;
                                    ; stack and for the next iteration, we  ;
                                    ; want to set z := z*w.                 ;
                                    ;                                       ;
    FLD     ST(0)                   ; push Re(z)                            ;
    FMUL    ST(0), ST(4)            ; ST(0) <- Re(z)*Im(w)                  ;
    FLD     ST(2)                   ; push Im(z)                            ;
    FMUL    ST(0), ST(4)            ; ST(0) <- Im(z)*Re(w)                  ;
    FADDP   ST(1), ST(0)            ; TOS   <- Im(z*w)                      ;
    FXCH    ST(2)                   ; set new Im(z)                         ;
    FMUL    ST(0), ST(4)            ; ST(0) <- Im(z)*Im(w)                  ;
    FXCH    ST(1)                   ; ST(0) <-> ST(1)                       ;
    FMUL    ST(0), ST(3)            ; ST(0) <- Re(z)*Re(w)                  ;
    FSUBP   ST(1), ST(0)            ; ST(0) <- -Re(z*w)                     ;
    FCHS                            ; ST(0) <- Re(z*w)                      ;
                                    ;                                       ;
    SHR     EAX, 4                  ; unscale indices again                 ;
                                    ;                                       ;
    SUB     EAX, ECX                ; eax := (k+j)-j = k                    ;
    INC     EAX                     ; increase by one                       ;
    CMP     EAX, EDX                ; check whether k<M                     ;
    JL      INNER2                  ; if yes, loop again                    ;
                                    ; the inner loop ends here:             ;
    FCOMPP                          ; pop z off the stack                   ;
    ADD     ECX, EBX                ; j += N                                ;
    CMP     ECX, [ESP+8]            ; check whether j < n                   ;
    JL      INNER1                  ; if yes, loop again                    ;
                                    ;                                       ;
                                    ; the outer loop ends here. We now want ;
                                    ; to calculate w := w*w and simply jump ;
                                    ; back to START where the N>1 condition ;
                                    ; is checked.                           ;
                                    ;                                       ;
    FLD     ST(1)                   ; Push Im(w) onto stack                 ;
    FMUL    ST(0), ST(1)            ; ST(0) := Re(w)*Im(w)                  ;
    FLD     ST(0)                   ; Push ST(0) again                      ;
    FADDP   ST(1), ST(0)            ; ST(0) = 2*Re(w)*Im(w)                 ;
    FXCH    ST(2)                   ; exchange it with Im(w)                ;
    FMUL    ST(0), ST(0)            ; ST(0) := Im(w)*Im(w)                  ;
    FXCH    ST(1)                   ; exchange it with Re(w)                ;
    FMUL    ST(0), ST(0)            ; ST(0) := Re(w)*Re(w)                  ;
    FSUBP   ST(1), ST(0)            ; ST(0) = Im(w)*Im(w)-Re(w)*Re(w)       ;
    FCHS                            ; invert sign, done                     ;
                                    ;                                       ;
    MOV     EBX, EDX                ; N := M                                ;
    JMP     START                   ; and again                             ;
                                    ;                                       ;
                                    ; The transformation has now been       ;
                                    ; performed completely. All that is     ;
                                    ; left to do is the bit reversal.       ;
ENDFUN:                             ;                                       ;
    XOR     EDX, EDX                ; edx will be first index               ;
    MOV     EAX, EDX                ; eax the second                        ;
    MOV     EBX, DWORD PTR [ESP+8]  ; ebx stores n                          ;
BREV:                               ;                                       ;
    CMP     EDX, EAX                ; only swap values if                   ;
    JLE     NOSWAP                  ; edx > eax                             ;
    SHL     EDX, 4                  ;                                       ;
    SHL     EAX, 4                  ;                                       ;
    FLD     QWORD PTR [ESI+EDX]     ;                                       ;
    FLD     QWORD PTR [ESI+EDX+8]   ;                                       ;
    FLD     QWORD PTR [ESI+EAX]     ;                                       ;
    FLD     QWORD PTR [ESI+EAX+8]   ;                                       ;
    FSTP    QWORD PTR [ESI+EDX+8]   ;                                       ;
    FSTP    QWORD PTR [ESI+EDX]     ;                                       ;
    FSTP    QWORD PTR [ESI+EAX+8]   ;                                       ;
    FSTP    QWORD PTR [ESI+EAX]     ;                                       ;
    SHR     EDX, 4                  ;                                       ;
    SHR     EAX, 4                  ;                                       ;
NOSWAP:                             ;                                       ;
    MOV     ECX, EBX                ; calculate bitreversal:                ;
CLOOP:                              ;                                       ;
    SHR     ECX, 1                  ; ecx is of the form 1<<k.              ;
    XOR     EDX, ECX                ; XOR ecx to edx until the result of    ;
    CMP     EDX, ECX                ; that XOR is not 0, hence ecx<=edx     ;
    JL      CLOOP                   ; otherwise we have a 'carry'.          ;
    INC     EAX                     ; increase normal index                 ;
    CMP     EAX, EBX                ; and loop until we're done             ;
    JL      BREV                    ;                                       ;
    MOV     EAX, ESI                ; return f                              ;
    FLDENV  [ESP-28]                ;                                       ;
    RET                             ;                                       ;
_fft ENDP                           ;                                       ;
                                    ;                                       ;
END                                 ;                                       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;